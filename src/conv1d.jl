"""
    conv1d(X::AbstractArray, Y::AbstractArray)

Calculate the direct convolution of two vectors.

# Examples

```julia
using HLConv

X = rand(10)
Y = rand(5)

out = conv1d(X, Y)
```

!!! tips
    The real calculation will be offloaded to the C backend generated by Halide.

    Thus the performance will be much better if you're using plain `Array` types with
    built-in Halide types, e.g., `Int8`, `UInt8`, `Float32`, `Float64`, etc.

    For inputs of other types, they will be converted to dense array first
    (thus allocating memories) and then passed to the C backend. This is also
    true for the in-place version [`conv1d!`](@ref).

    See [`HLTypes`](@ref) for the complete list of built-in Halide types.

See [`conv1d!`](@ref) for the in-place version.
"""
function conv1d(X::AbstractArray, Y::AbstractArray)
  OT = promote_type(eltype(X), eltype(Y))
  OT = isabstracttype(OT) ? Float64 : OT

  out = similar(X, OT, calculate_conv_out_spec(X, Y))
  return conv1d!(out, X, Y)
end

"""
    conv1d!(out::AbstractArray, X::AbstractArray, Y::AbstractArray)

The in-place version of the direct convolution of two vectors.

# Examples

```julia
using HLConv

X = rand(10)
Y = rand(5)
out = Array{Float64}(undef, 14)

conv1d!(out, X, Y)
```

This function may or may not allocate memories so as to call the C backend.

See also [`conv1d`](@ref) for the non-in-place version.
"""
function conv1d!(out::AbstractArray, X::AbstractArray, Y::AbstractArray)
  # For generic array output case, we need to allocate a dense array first
  # and then copy the result to `out`.
  dense_out = Array{eltype(out),1}(undef, calculate_conv_out_spec(X, Y))
  conv1d!(dense_out, X, Y)
  out .= dense_out
  return out
end

function conv1d!(out::Array, X::AbstractArray, Y::AbstractArray)
  # for generic element type, we introduce a Float64 buffer
  dense_out = Array{Float64,1}(undef, calculate_conv_out_spec(X, Y))
  conv1d!(dense_out, X, Y)
  out .= dense_out
  return out
end

function conv1d!(out::Array{T}, X::AbstractArray, Y::AbstractArray) where {T<:HLTypes}
  calculate_conv_out_spec(X, Y) == length(out) ||
    throw(ArgumentError("Output array size does not match the expected size."))

  if ndims(X) != 1 || ndims(Y) != 1
    throw(ArgumentError("Both X and Y must be 1D arrays."))
  end

  if length(X) < length(Y)
    return conv1d!(out, Y, X)
  end

  # Here the conversion might create a new array, depending on the type of `X` and `Y`.
  BT = Buffer{eltype(out),1}
  _conv1d!(convert(BT, X), convert(BT, Y), convert(BT, out))

  # for dense array case, `out` and `convert(BT, out)` shares the same memory
  # so we can return `out` directly
  return out
end

function _conv1d!(X::Buffer{T}, K::Buffer{T}, out::Buffer{T}) where {T<:HLTypes}
  rst = libconv.conv1d(T, X.ptr, K.ptr, out.ptr)
  if rst != 0
    throw(ArgumentError("Invalid input data."))
  end
  return out
end
